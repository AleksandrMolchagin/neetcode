---
title: 2181. Merge Nodes in Between Zeros
date: July 4, 2024
---
# Problem

>[!question]
>You are given theÂ `head`Â of a linked list, which contains a series of integersÂ **separated**Â byÂ `0`'s. TheÂ **beginning**Â andÂ **end**Â of the linked list will haveÂ `Node.val == 0`. ForÂ **every**Â two consecutiveÂ `0`'s,Â **merge**Â all the nodes lying in between them into a single node whose value is theÂ **sum**Â of all the merged nodes. The modified list should not contain anyÂ `0`'s. ReturnÂ _the_Â `head`Â _of the modified linked list_.

**Example 1:**

![](https://assets.leetcode.com/uploads/2022/02/02/ex1-1.png)

**Input:** head = [0,3,1,0,4,5,2,0]
**Output:** [4,11]
**Explanation:** 
The above figure represents the given linked list. The modified list contains
- The sum of the nodes marked in green: 3 + 1 = 4.
- The sum of the nodes marked in red: 4 + 5 + 2 = 11.

**Example 2:**

![](https://assets.leetcode.com/uploads/2022/02/02/ex2-1.png)

**Input:** head = [0,1,0,3,0,2,2,0]
**Output:** [1,3,4]
**Explanation:** 
The above figure represents the given linked list. The modified list contains
- The sum of the nodes marked in green: 1 = 1.
- The sum of the nodes marked in red: 3 = 3.
- The sum of the nodes marked in yellow: 2 + 2 = 4.

**Constraints:**

- The number of nodes in the list is in the rangeÂ `[3, 2 * 105]`.
- `0 <= Node.val <= 1000`
- There areÂ **no**Â two consecutive nodes withÂ `Node.val == 0`.
- TheÂ **beginning**Â andÂ **end**Â of the linked list haveÂ `Node.val == 0`.
---
# Solutions

## 1.  Single Pass with a new LinkedList

**Time Complexity:** $O(n)$  |  **Space Complexity:**Â $O(n)$

To solve the problem, we create a new linked list with a dummy head nodeÂ `new_head`. We traverse the original linked list in a single pass. For each node in the original list, if its value is notÂ `0`, we add its value toÂ `temp_sum`. When we encounter a node with a value ofÂ `0`, we create a new node with the value ofÂ `temp_sum`Â in the output linked list, then resetÂ `temp_sum`Â toÂ `0`Â to start accumulating the sum for the next segment.

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val = val
#         self.next = next

class Solution:
    def mergeNodes(self, head: Optional[ListNode]) -> Optional[ListNode]:
        new_head = ListNode(0)
        new_cur = new_head
        temp_sum = 0

        cur = head.next  # Skip the initial 0 node
        while cur:
            if cur.val == 0:
				new_cur.next = ListNode(temp_sum)
				new_cur = new_cur.next
                temp_sum = 0
            else:
                temp_sum += cur.val
            
            cur = cur.next

        return new_head.next

```

---

## 2.  #ğŸ†  Single Pass with in-place Modifications

**Time Complexity:** $O(n)$  |  **Space Complexity:**Â $O(1)$

We can slightly modify the approach above to achieveÂ O(1)O(1)Â space complexity. We use aÂ `modify`Â pointer to keep track ofÂ `0`-valued ListNodes, store the sum in their values, and connect them together.

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next

class Solution:
    def mergeNodes(self, head: Optional[ListNode]) -> Optional[ListNode]:

        temp_sum = 0
        modify_prev = head
        modify = head
        cur = head.next  # Skip the initial 0 node
        while cur:
            if cur.val == 0:
                modify_prev = modify
                modify.val = temp_sum
                modify.next = cur
                modify = modify.next
                temp_sum = 0
            else:
                temp_sum += cur.val
            
            cur = cur.next

        modify_prev.next = None

        return head

```

---
## 3. Recursive

**Time Complexity:** $O(n)$  |  **Space Complexity:**Â $O(n)$

We can also approach the problem recursively by breaking it into fragments, where we find the sum of values betweenÂ `0`-valued nodes. In our design, we can guarantee that the head is eitherÂ `0`Â orÂ `None`. We modify the head's value to store the sum and recursively process the list from the nextÂ `0`-valued node.

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def mergeNodes(self, head: Optional[ListNode]) -> Optional[ListNode]:

        if not head:
            return None
        
        node = head.next
        node_sum = 0
        while node and node.val != 0:
            node_sum += node.val
            node = node.next

        head.val = node_sum
        head.next = self.mergeNodes(node)

        return head.next if head.val == 0 else head

```